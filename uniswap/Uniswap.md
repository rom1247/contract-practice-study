# 什么是Uniswap

## 传统中心化交易所

传统中心化交易所（Centralized Exchange，CEX）是一个中心化交易所，由中心化机构运营、托管用户资产、通过订单簿撮合交易的交易平台。

### CEX有三个核心的角色

- 用户
  - 充值到交易所
  - 下单买卖
  - 成交后查看账号余额于提现
- 交易所（银行 + 交易系统 + 清算所）
  - 托管用户资产
  - 维护订单簿
    - 用户挂单后没有被撮合，就会在订单簿里等待，就是所谓的限价单
  - 撮合订单
  - 清算
  - 风控
  - 合规
- 做市商（Market Maker）
  - 在买卖两侧持续挂单
  - 缩小买卖价差（Spread）
  - 提供深度
    - 在价格附近，有多少真实可成交的量（如果没有深度，价格会在一个价格路上的上扫，导致价格被自己拉高）

        ```mathematica
        卖单（Ask）
        100.10  500 股
        100.20  500 股
        100.30  500 股
        ———————
        买单（Bid）
        100.00  500 股
        99.90   500 股
        99.80   500 股
        ```

        如果是买小于500股，那么都会在100.10这个价格上成交，这就是深度的好处，而做市商可以持续更新价格，并同时挂很多买单和卖单

### CEX 的核心机制：订单簿（Order Book）

订单薄就是买单和卖单集合，是一个有价格深度的列表
订阅类型：

- 限价单（Limit Order）：指定价格，等别人来成交
- 市价单（Market Order）：立即成交，吃掉订单薄里的挂单

交易所在撮合订单的一般遵循价格优先，再时间优先。

流程：

```css
用户 / 做市商
    ↓ 下单
订单簿（Order Book）
    ↓ 撮合
撮合引擎
    ↓
成交 & 账户变动

```

## Uniswap

Uniswap白皮书中的定义：
> Uniswap is a protocol for automated token exchange on Ethereum. It is designed around ease-of-use, gas efficiency, censorship resistance, and zero rent extraction.
> 解释：Uniswap是一个基于以太坊的自动代币交换协议，它的设计目标是：易用性、gas高利用率、抗审查性和零抽租。

也可以理解它是一个用智能合约实现的、无需订单簿、无需做市商的自动化交易系统（去中心化交易所（DEX）+ 自动化做市商（AMM））。

### 一些概念解释

AMM ： 自动化做市商（Automatic Market Maker）
DEX ： 去中心化交易所（Decentralized Exchange）
LP ： 流动性提供者（Liquidity Provider）
流动池 ： 锁定在智能合约中所有的代币以及资金的总称，流动是资金转为代币，或代币转为资金的意思
恒定乘法公式 ： $x×y=k$，其中x和 y分别代表流动池中两种资产的数量，k是两种资产数量的乘积
交易滑点：实际成交价格与你下单时“看到/预期的价格”之间的差异

### 传统中心化交易所和Uniswap的区别

| 传统中心化交易所 | Uniswap |
| -------- | ------- |
| 需要撮合订单   | 无订单簿    |
| 需要做市商    | 所有人都可做市 |
| 需要托管资产   | 非托管     |

### Uniswap的设计架构

```css

用户
 ↓
Exchange 合约（每个 Token 一个）
 ↓
ETH ↔ ERC20

```

Uniswap只支持ETH和ERC20代币交易，不支持其他的代币。
而LP就是把 ETH + Token 存进池子的人，在传统中心化交易所中深度是价格附近的可成交量，在Uniswap中是池子里 ETH 和 Token 的数量。
其中池子越大，交易滑点越小，交易体验越好。

#### LP加入和赎回设计

uniswap启动后，合约会固定一个ETH和ERC20的比例，成为LP就要存入这个比例的ETH和ERC20，然后获得一个LP token的凭证，相当于池子的一个比例（比如10%），
LP赎回的时候，也是按这个LP token的比例赎回当前池子的ETH和ERC20的占比，同时合约会销毁池子等量的ETH和ERC20。
这个设计自动实现了LP的收益和损失。

### 手续费机制下的输入、输出与池子变化的完整关系（帮助理解交易）

交易手续费固定：从输入的资产中扣除0.3%的手续费
定价基准：恒定乘法公式（$x×y=k$）

#### 一、交易前状态

在任意一次 swap 发生之前，池子状态为：

- ETH 储备：x
- Token 储备：y

此时：

- 定价池子 = 真实池子
- 定价遵循：x · y = k

#### 二、用户输入资产（Input）

用户发起一笔交易（以 ETH → Token 为例）：用户输入：Δx ETH 。

#### 三、手续费的作用方式（0.3%）

Uniswap  对每笔交易收取 0.3% 手续费，其实现方式不是“扣走”，而是：

```css
参与定价的输入：
Δx_fee = Δx × 997 / 1000
```

含义：Δx_fee 用于计算价格、决定输出数量，0.003Δx 不参与定价，直接留在池子中

#### 四、输出资产的计算（Output）

输出资产数量（Token）由定价池子决定：

```css
token_out =(y × Δx_fee) / (x + Δx_fee)

这是用定价公式推导出来的
(x + Δx_fee) × (y - token_out) = x × y

```

关键点：输出只与 Δx_fee 有关，手续费部分不会换成 Token，而是留在池子中

五、定价池子的变化（用于计算价格）

在定价意义上，交易完成后池子被“视为”：

- 定价 ETH 储备：x + Δx_fee
- 定价 Token 储备：y − token_out

并满足：

```css
(x + Δx_fee)(y − token_out) = x · y

```

结论：定价池子只反映“有效输入”，定价规则保持连续、可预测

#### 六、真实池子的变化（LP 实际拥有的资产）

在真实世界中，池子的变化是：

- 真实 ETH 储备：x_real = x + Δx
- 真实 Token 储备：y_real = y − token_out

与定价池子相比：

- ETH 多了：0.003Δx
- Token 完全一致

所以真实池子的计算：

```css
(x + Δx_fee + 0.003Δx)(y − Δy)
```

结论：只要发生了交易，真实池子就会比定价池子大，这就是LP 赚的是“真实池子与定价池子之间的差值”

#### 七、定价池子 vs 真实池子的核心差异

| 项目       | 定价池子         | 真实池子         |
| -------- | ------------ | ------------ |
| ETH 增量   | `Δx_fee`     | `Δx`         |
| Token 变化 | `−token_out` | `−token_out` |
| 是否包含手续费  |  不包含        | 包含         |
| 作用       | 决定价格与输出      | 承载 LP 资产     |

#### 八、手续费对 LP 的最终影响

- 手续费不会影响当笔交易的输出数量
- 手续费以 额外资产 的形式留在真实池子中
- LP 不需要单独领取手续费
- 所有 LP 按份额自动共享这部分增长

总结：手续费通过“输入拆分”为定价输入与沉淀资产，使得定价池子保持 x·y=k，而真实池子持续累积资产，这正是 LP 收益的根本来源。

### 无常损失（Impermanent Loss）

无常损失不是“亏钱”，而是相对于单纯持币（HODL）的收益差

#### 无偿损失是怎么产生的

根本原因：LP 必须持续服从 $x×y=k$ 的定价约束
这就意味着当市场的价格变化时，池子会强制调整，LP会被动的调整资产，卖出多就涨价资产，买入多就跌价资产

一个没有手续费例子（方便理解）：

**初始状态：**
池子：

  ```css
  10 ETH *1000 Token
  ```

市价：1 ETH = 100 Token

**市场价格上涨 2 倍**

新市价：1 ETH = 200 Token

套利发生后，池子会调整到：

```css
根据 y / x = 200 和 x · y = 10000 计算

ETH：10 / √2 ≈ 7.07

Token：1000 × √2 ≈ 1414
```

LP 此时池子总价值：

```css

7.07 ETH × 200 = 1414 Token
+ 1414 Token
= 2828 Token
```

如果你什么都不做（HODL）：

```css
10 ETH × 200 = 2000 Token
+ 1000 Token
= 3000 Token
```

差值：

```css
2828 / 3000 ≈ 0.943

 LP 少了约 5.7%（1 - 0.943）
```

这就是无常损失。
为什么要叫无常，这是因为主要价格回到初始市价（1 ETH = 100 Token），那么池子总量就回到初始总量（10 ETH *1000 Token），这就是无常损失的根本原因。
所以可以理解为只要发生交易就会发生无常损失LP的资产损失，而uniswap的手续费设计就是给予LP这种资产损失的补偿。

总结：LP最大化收益就是频繁交易，并池子总量是向初始总量靠近的。而交易者则是赚走或者损失这其中的价格差

## uniswap v2

核心机制还是恒定乘积公式，但是x和y是任意的REC20代币，而不是ETH，LP提供等值的两种代币（ERC20 + ERC20）

### 相比uniswap v1有什么改进

1. 任意 ERC20 ↔ ERC20 交易对
   - V2 支持任意两个 ERC20 代币直接形成交易对，无需中间经过 ETH，减少了交易成本（不再需要两次交易），提高了交易效率
2. 闪电贷（Flash Loan）
   - 允许用户在一次交易中借出任意数量代币，只要在交易结束前归还。
   - 这为去中心化金融（DeFi）提供了无限组合可能，例如套利、清算、杠杆交易。
3. 时间加权平均价格（TWAP, Time-Weighted Average Price）预言机
   - V2 引入了 Cumulative Price 机制，可以安全地生成价格预言机。
   - 相比 V1，V2 的价格机制更适合 DeFi 项目使用，降低了操纵风险。
4. ERC20 ↔ ERC20 池（无需 ETH 桥接）
   - V1 中如果你想把 DAI ↔ USDC 交易，你必须先 DAI → ETH → USDC。
   - V2 中可直接 DAI ↔ USDC，减少滑点和交易成本。
5. 流动性代币（LP Token）改进
   - V2 的 LP Token 是 ERC20 标准代币，便于在其他 DeFi 协议中抵押或使用。
   - 支持准确的流动性份额计算，避免因手续费分配不均产生的偏差。
6. 更安全的闪电贷和交易逻辑
   - 增加了内部检查，防止某些类型的攻击，如重入攻击。
7. 优化交易与费用结构
   - 交易费保持 0.3%，但手续费分配逻辑更明确
   - LP 收益 = 交易手续费 + 价格变动导致的持币损益（impermanent loss）

### 时间加权平均价格（TWAP, Time-Weighted Average Price）预言机

首先回顾一下uniswapv1的价格公式

```css
price_xy = x / y
```

这是一个瞬时状态值，大笔交易能瞬间改变价格，并且只需要一个区块就能完成改价，这就容易被操纵，在机构需求是价格要相对稳定，所以uniswap v2引入了TWAP（时间加权平均价格），解决如何在链上，没有外部预言机的情况下，提供一个难以被短期操纵的价格。

TWAP 的核心思想是：短时间操纵比较容易，长时间操纵则代价非常大，于是设计的目标就是要一段时间内的平均价格。

那具体是如何做的呢？
设计是保存一个价格 * 时间的累计值（Cumulative Price）

公式：

``` solidity
priceCumulative += price * timeElapsed;
```

在链上合约中：

``` solidity
uint256 price0CumulativeLast; //token0 除以 token1 计价的“价格×时间”累计值
uint256 price1CumulativeLast;  //token1 除以 token0 计价的“价格×时间”累计值
uint32  blockTimestampLast;  //上一次更新的区块时间

//更新操作：交易、流动性增加或移除
...
uint32 timeElapsed = currentTimestamp - blockTimestampLast

price0 = reserve1 / reserve0
price1 = reserve0 / reserve1

price0Cumulative += price0 * timeElapsed
price1Cumulative += price1 * timeElapsed

price0CumulativeLast = price0Cumulative
price1CumulativeLast = price1Cumulative
blockTimestampLast = currentTimestamp
...

```

uniswap v2合约只提供时间点的价格积分，而外部合约只需要在T1 和 T2 分别取一次数据，然后相减差值除于时间差

$$
TWAP =
\frac{
priceCumulative(t_2) - priceCumulative(t_1)
}{
t_2 - t_1
}
$$

### 闪电贷\闪电兑换（Flash Loan）

在EVM中，闪电贷其实是一笔交易，借款、使用、还款是在同一笔交易中完成，所以要么全部成功，要么全部失败回滚，这是闪电贷的核心约束条件。

基本流程：

```css
1. 借出资金
2. 执行用户逻辑（套利 / 清算 / 交换）
3. 校验资金是否归还 + 手续费
4. 成功 → 交易完成
   失败 → revert

```

闪电贷能做什么：

- 套利
  - 借钱 → 买 → 卖 → 还钱 → 利润
- 清算
  - 借钱 -> 清算别人仓位 -> 盈利
- 抵押重组
  - 借钱 → 还旧债 → 重新抵押 → 借新债

### 流动性代币（LP Token）改进

#### 概念

LP Token = 流动性份额的链上凭证
LP Token代表池子资产的份额，包括手续费的收益权，并本身就是ERC20代币

#### 改进

1. 通用 ERC20 ↔ ERC20 支持
2. 更精确的份额计算模型
3. 最小流动性锁定（MINIMUM_LIQUIDITY）
4. 为协议手续费预留铸币机制

## uniswap v3

> Uniswap V3 = 把「全价格区间共享流动性」 → 变成「LP 自己选择价格区间的集中流动性 AMM」

V2：

- 所有 LP 的钱 铺满 (0, +∞)
- 大多数资金在“永远不会成交的价格区间”里躺平

V3：

- LP 只在自己看好的价格区间提供流动性
- 同样资金 → 更高资金利用率

那么v3解决了什么问题：

- 资金利用率低，v2大量的资金在躺平，v3则使用集中流行性，LP可以在一个区间提供流行性
- LP收益被动，v2所有LP收益相同（按份额），v3可以自主选择价格区间，提高手续费收益
- 优化做市结构，v2不能像传统CEX一样做市结构（限价单，价格深度，动态报价），v3可以用多个区间的组合实现类型CEX的做市结构，也可以实现v2的结构（足够大的区间）
  
### 概念解释

| 概念 | 名词解释 |
| --- | --- |
| **Concentrated Liquidity（集中流动性）** | LP 不再向整个价格轴提供流动性，而是只在自选的价格区间内提供，从而提升资金利用率 |
| **Price Range（价格区间）** | LP 设定的流动性生效区间 `[P_lower, P_upper]`，只有当当前价格落在该区间内，LP 才参与交易并赚取手续费 |
| **Active Liquidity（活跃流动性）** | 覆盖当前价格的所有 LP 区间对应的流动性之和，是 Swap 实际使用的流动性 |
| **Inactive Liquidity（非活跃流动性）** | 当前价格不在其区间内的 LP 流动性，不参与交易、不产生手续费 |
| **Tick** | 价格的最小离散单位，V3 不允许连续价格，而是将价格映射到一系列整数 tick |
| **Tick Spacing** | 相邻可用 tick 的最小间隔，由手续费档决定，用于控制价格精度与 Gas 成本 |
| **Tick Range** | LP 选择的 `[tickLower, tickUpper]`，实际对应一个价格区间 |
| **Current Tick** | 当前价格所在的 tick，是判断流动性是否活跃的关键 |
| **Liquidity（L）** | V3 中的核心变量，表示在某一价格区间内可用的流动性强度，而不是某种 Token 数量 |
| **√P（平方根价格）** | V3 内部统一使用的价格表示形式，用于线性计算 Token 数量与流动性 |
| **Segmented AMM Curve（分段 AMM 曲线）** | 整个交易价格曲线由多个区间内的 AMM 曲线拼接而成，每个区间内流动性不同 |
| **LP Position** | LP 在某个池子中、某个手续费档、某个价格区间内提供的一笔独立流动性 |
| **Position NFT（ERC721）** | 用 NFT 表示的 LP 头寸，记录区间、流动性数量、已赚手续费等信息 |
| **Position Manager** | 用于 Mint / Burn / Increase / Decrease 流动性的管理合约 |
| **Fee Tier（手续费档）** | 池子创建时选择的手续费比例，如 0.05%、0.3%、1%，不同档对应不同 tick spacing |
| **Fee Accrual（手续费累积）** | Swap 产生的手续费按流动性权重累积到区间内的 LP Position |
| **Fee Growth Inside** | 用于计算某个区间内应得手续费的累计指标 |
| **Claim Fees（提取手续费）** | LP 主动从 Position 中提取已赚取但尚未领取的手续费 |

### 集中流动性

首先在v3里，引入一个变量L，在某一价格区间内可用的流动性强度，是价格在曲线上移动1个最小单位时，池子能吸收的交易规模。
也可以理解为一个价格区间的“v2版本流动性”，是v3整个价格曲线的一个片段。

那么这个L 是怎么来的呢？
先回顾一下v2的数学模型：
$$
x \cdot y = k
$$

边界价格P:
$$
P = \frac{dy}{dx}
$$

然后用价格P来计算x和y：


$$
y = P x
$$

代回不变量：

$$
x \cdot (P x) = k
$$

$$
x^2 P = k
$$

然后解出x和y：

$$
x^2 = \frac{k}{P}
$$

$$
x = \frac{\sqrt{k}}{\sqrt{P}}
$$

同理：

$$
y = P x = \sqrt{k}\sqrt{P}
$$

关键来了，v3的设计把 $\sqrt{k}$ 单独抽象成一个变量，称为流动性 $L$
定义：  

$$
L := \sqrt{k}
$$

于是：

$$
x = \frac{L}{\sqrt{P}}, \quad
y = L\sqrt{P}
$$

有了流动性$L$后，设计者就把这个流动性，从v2概念里x和y的控制关系，提升为一个显示控制变量。
所以LP最后直接操作的也就是这个$L$，这个推导过程中，v3并没有舍弃v2中$x \cdot y = k$这个核心函数，只是重新定义一个变量描述这个函数状态，它变成了一个参数，由LP 自己控制。

即然流动性$L$是已经是一个可控制的变量，那LP就可以决定自己资产放在哪个价格区间内，只要在这个区间内，LP 就可以获得收益，而区间外就没有提供流行性了，自然就无法获取收益（v3限价单设计由此而来）。

v2和v3的流动性直观对比
v2：

```less
价格轴: 0 -------------------- ∞
        [所有 LP 的钱铺满]

```

v3：

```less
价格轴: 0 --------------------------------- ∞

LP A:         [====]
LP B:              [=========]
LP C:    [=========================]

```

对比结果

| 指标 | V2 | V3 |
| ------ | ------- | ----------- |
| 区间内流动性 | 低 | **高很多** |
| 滑点 | 大 | **小** |
| 手续费 | 分给所有 LP | **几乎你一个人拿（重叠越小，拿的越多）** |
| 资金效率 | 低 | **指数级提升** |

**总结：集中流动性就是LP不在这个价格轴上提供流动性了，而是只选择有限的价格区间提供流动性，在区间内LP的资金以更高的流行性密度参与定价和交易，在区间外完全不参与。**

### V3 的交易和数学变化

问题：
LP已经提供了流动性，交易者就可以就进行买卖了，现在流动性是一个价格区间，那么当前出价想要知道在哪个价格区间内，正常情况下就是遍历所有的LP判断当前价格有没有超过它的区间边界，但是现在的环境是链上，这个的效率非常低，并会产生高额gas费用，还需要用自己承担，这是不能接受的。

于是v3引入tick这个概念（离散的价格点）来解决这个问题，价格区间就是一个ticks，一个整数索引（能被TickSpacing整除），对应一个离散的价格边界点。

白皮书的概念：每个价格P都存在一个tick点，该点事1.0001的整数幂，通过整数索引i标识tick点，每个点的价格由以下公式得出：

$$\text{p}(i) = 1.0001^{i}$$

tick的索引i可以通过上面公式两边取对数求得以下公式：

$$i = \log_{1.0001}(P)$$

那么TickSpacing又是干嘛的呢？
TickSpacing第一个作用就是决定tisks里有多少个有效 tick。
假设现在有个ticks有100个tick，TickSpacing=10，那么ticks里就只有10个有效tick，其他tick都是无效的（但是仍然存在）。

### LP 不再是 ERC20，而是 NFT

### 手续费模型升级

### Impermanent Loss 在 V3 的新形态

### 链上的做市结构

### Oracle 改进（比 V2 强）
